a46c70da (dashbrown         2016-03-07 20:55:04 -0500   1) /*
2259a23f (benstevens        2016-03-12 22:19:49 -0500   2)  * FishController.java
a46c70da (dashbrown         2016-03-07 20:55:04 -0500   3)  *
ca2f299a (dashbrown         2016-03-07 22:09:22 -0500   4)  * Author: Walker M. White && Dashiell Brown
a46c70da (dashbrown         2016-03-07 20:55:04 -0500   5)  * Based on original PhysicsDemo Lab by Don Holden, 2007
a46c70da (dashbrown         2016-03-07 20:55:04 -0500   6)  * LibGDX version, 2/6/2015
a46c70da (dashbrown         2016-03-07 20:55:04 -0500   7)  */
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500   8) package edu.cornell.gdiac.physics.fish;
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500   9) 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  10) import java.util.ArrayList;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  11) 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  12) import com.badlogic.gdx.math.*;
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400  13) import com.badlogic.gdx.Gdx;
a1eb899a (benstevens        2016-03-10 11:06:51 -0500  14) import com.badlogic.gdx.Input;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  15) import com.badlogic.gdx.assets.*;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  16) import com.badlogic.gdx.audio.*;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  17) import com.badlogic.gdx.graphics.*;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  18) import com.badlogic.gdx.graphics.g2d.*;
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400  19) import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  20) import com.badlogic.gdx.physics.box2d.*;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  21) 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  22) import edu.cornell.gdiac.util.*;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  23) import edu.cornell.gdiac.physics.*;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  24) import edu.cornell.gdiac.physics.obstacle.*;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  25) 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  26) /**
2259a23f (benstevens        2016-03-12 22:19:49 -0500  27)  * Gameplay specific controller for Downstream.
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  28)  *
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  29)  * You will notice that asset loading is not done with static methods this time.  
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  30)  * Instance asset loading makes it easier to process our game modes in a loop, which 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  31)  * is much more scalable. However, we still want the assets themselves to be static.
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  32)  * This is the purpose of our AssetState variable; it ensures that multiple instances
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  33)  * place nicely with the static assets.
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  34)  */
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500  35) public class FishController extends WorldController implements ContactListener {
ca2f299a (dashbrown         2016-03-07 22:09:22 -0500  36) 	/** Reference to the fish texture */
2259a23f (benstevens        2016-03-12 22:19:49 -0500  37) 	private static final String KOI_TEXTURE = "fish/fish3.png";
ca2f299a (dashbrown         2016-03-07 22:09:22 -0500  38) 	/** The reference for the tether textures  */
2259a23f (benstevens        2016-03-12 22:19:49 -0500  39) 	private static final String TETHER_TEXTURE = "fish/lilypad.png";
2259a23f (benstevens        2016-03-12 22:19:49 -0500  40) 	/** Reference to the enemy image assets */
2259a23f (benstevens        2016-03-12 22:19:49 -0500  41) 	private static final String ENEMY_TEXTURE = "fish/enemy.png";
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  42) 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  43) 	/** The asset for the collision sound */
2259a23f (benstevens        2016-03-12 22:19:49 -0500  44) 	private static final String  COLLISION_SOUND = "fish/bump.mp3";
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  45) 	/** The asset for the main afterburner sound */
2259a23f (benstevens        2016-03-12 22:19:49 -0500  46) 	private static final String  MAIN_FIRE_SOUND = "fish/afterburner.mp3";
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  47) 	/** The asset for the right afterburner sound */
2259a23f (benstevens        2016-03-12 22:19:49 -0500  48) 	private static final String  RGHT_FIRE_SOUND = "fish/sideburner-right.mp3";
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  49) 	/** The asset for the left afterburner sound */
2259a23f (benstevens        2016-03-12 22:19:49 -0500  50) 	private static final String  LEFT_FIRE_SOUND = "fish/sideburner-left.mp3";
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  51) 	
2259a23f (benstevens        2016-03-12 22:19:49 -0500  52) 	/** Texture assets for the koi */
2259a23f (benstevens        2016-03-12 22:19:49 -0500  53) 	private TextureRegion koiTexture;
2259a23f (benstevens        2016-03-12 22:19:49 -0500  54) 	/** Texture assets for the lilypads */
ca2f299a (dashbrown         2016-03-07 22:09:22 -0500  55) 	private TextureRegion tetherTexture;
2259a23f (benstevens        2016-03-12 22:19:49 -0500  56) 	/** Texture assets for the enemy fish */
2259a23f (benstevens        2016-03-12 22:19:49 -0500  57) 	private TextureRegion enemyTexture;
2259a23f (benstevens        2016-03-12 22:19:49 -0500  58) 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  59) 	/** Texture filmstrip for the main afterburner */
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  60) 	private FilmStrip mainTexture;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  61) 	/** Texture filmstrip for the main afterburner */
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  62) 	private FilmStrip leftTexture;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  63) 	/** Texture filmstrip for the main afterburner */
2259a23f (benstevens        2016-03-12 22:19:49 -0500  64) 	private FilmStrip rightTexture;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  65) 	
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500  66) 	/** Track asset loading from all instances and subclasses */
2259a23f (benstevens        2016-03-12 22:19:49 -0500  67) 	private AssetState fishAssetState = AssetState.EMPTY;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  68) 	
0e3c00aa (dashbrown         2016-03-07 21:20:57 -0500  69) 	private boolean tethered;
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400  70) 	
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400  71) 	private boolean enableSlow = false;
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400  72) 	private boolean enableLeadingLine = false;
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400  73) 	private boolean enableTetherRadius = false;
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400  74) 	
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500  75) 	/**
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500  76) 	 * Preloads the assets for this controller.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500  77) 	 *
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  78) 	 * To make the game modes more for-loop friendly, we opted for nonstatic loaders
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  79) 	 * this time.  However, we still want the assets themselves to be static.  So
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  80) 	 * we have an AssetState that determines the current loading state.  If the
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  81) 	 * assets are already loaded, this method will do nothing.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500  82) 	 * 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  83) 	 * @param manager Reference to global asset manager.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500  84) 	 */
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500  85) 	public void preLoadContent(AssetManager manager) {
2259a23f (benstevens        2016-03-12 22:19:49 -0500  86) 		if (fishAssetState != AssetState.EMPTY) {
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500  87) 			return;
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500  88) 		}
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  89) 		
2259a23f (benstevens        2016-03-12 22:19:49 -0500  90) 		fishAssetState = AssetState.LOADING;
2259a23f (benstevens        2016-03-12 22:19:49 -0500  91) 
2259a23f (benstevens        2016-03-12 22:19:49 -0500  92) 		
2259a23f (benstevens        2016-03-12 22:19:49 -0500  93) 		manager.load(ENEMY_TEXTURE, Texture.class);
2259a23f (benstevens        2016-03-12 22:19:49 -0500  94) 		assets.add(ENEMY_TEXTURE);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  95) 		
a46c70da (dashbrown         2016-03-07 20:55:04 -0500  96) 		// Ship textures
2259a23f (benstevens        2016-03-12 22:19:49 -0500  97) 		manager.load(KOI_TEXTURE, Texture.class);
2259a23f (benstevens        2016-03-12 22:19:49 -0500  98) 		assets.add(KOI_TEXTURE);
ca2f299a (dashbrown         2016-03-07 22:09:22 -0500  99) 		
ca2f299a (dashbrown         2016-03-07 22:09:22 -0500 100) 		manager.load(TETHER_TEXTURE, Texture.class);
ca2f299a (dashbrown         2016-03-07 22:09:22 -0500 101) 		assets.add(TETHER_TEXTURE);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 102) 		
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 103) 		// Ship sounds
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 104) 		manager.load(MAIN_FIRE_SOUND, Sound.class);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 105) 		assets.add(MAIN_FIRE_SOUND);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 106) 		manager.load(LEFT_FIRE_SOUND, Sound.class);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 107) 		assets.add(LEFT_FIRE_SOUND);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 108) 		manager.load(RGHT_FIRE_SOUND, Sound.class);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 109) 		assets.add(RGHT_FIRE_SOUND);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 110) 		manager.load(COLLISION_SOUND, Sound.class);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 111) 		assets.add(COLLISION_SOUND);
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 112) 
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 113) 		super.preLoadContent(manager);
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 114) 	}
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 115) 
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 116) 	/**
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 117) 	 * Loads the assets for this controller.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 118) 	 *
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 119) 	 * To make the game modes more for-loop friendly, we opted for nonstatic loaders
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 120) 	 * this time.  However, we still want the assets themselves to be static.  So
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 121) 	 * we have an AssetState that determines the current loading state.  If the
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 122) 	 * assets are already loaded, this method will do nothing.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 123) 	 * 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 124) 	 * @param manager Reference to global asset manager.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 125) 	 */
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 126) 	public void loadContent(AssetManager manager) {
2259a23f (benstevens        2016-03-12 22:19:49 -0500 127) 		if (fishAssetState != AssetState.LOADING) {
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 128) 			return;
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 129) 		}
2259a23f (benstevens        2016-03-12 22:19:49 -0500 130) 
2259a23f (benstevens        2016-03-12 22:19:49 -0500 131) 		enemyTexture = createTexture(manager,ENEMY_TEXTURE,false);
2259a23f (benstevens        2016-03-12 22:19:49 -0500 132) 		koiTexture = createTexture(manager,KOI_TEXTURE,false);
ca2f299a (dashbrown         2016-03-07 22:09:22 -0500 133) 		tetherTexture = createTexture(manager,TETHER_TEXTURE,false);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 134) 		
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 135) 		SoundController sounds = SoundController.getInstance();
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 136) 		sounds.allocate(manager,MAIN_FIRE_SOUND);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 137) 		sounds.allocate(manager,LEFT_FIRE_SOUND);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 138) 		sounds.allocate(manager,RGHT_FIRE_SOUND);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 139) 		sounds.allocate(manager,COLLISION_SOUND);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 140) 		
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 141) 		super.loadContent(manager);
2259a23f (benstevens        2016-03-12 22:19:49 -0500 142) 		fishAssetState = AssetState.COMPLETE;
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 143) 	}
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 144) 	
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 145) 	// Physics constants for initialization
2259a23f (benstevens        2016-03-12 22:19:49 -0500 146) 	/** Density of non-enemy objects */
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 147) 	private static final float BASIC_DENSITY   = 0.0f;
2259a23f (benstevens        2016-03-12 22:19:49 -0500 148) 	/** Density of the enemy objects */
2259a23f (benstevens        2016-03-12 22:19:49 -0500 149) 	private static final float ENEMY_DENSITY   = 1.0f;
2259a23f (benstevens        2016-03-12 22:19:49 -0500 150) 	/** Friction of non-enemy objects */
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 151) 	private static final float BASIC_FRICTION  = 0.1f;
2259a23f (benstevens        2016-03-12 22:19:49 -0500 152) 	/** Friction of the enemy objects */
2259a23f (benstevens        2016-03-12 22:19:49 -0500 153) 	private static final float ENEMY_FRICTION  = 0.3f;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 154) 	/** Collision restitution for all objects */
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 155) 	private static final float BASIC_RESTITUTION = 0.1f;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 156) 	/** Threshold for generating sound on collision */
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 157) 	private static final float SOUND_THRESHOLD = 1.0f;
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 158) 	
2259a23f (benstevens        2016-03-12 22:19:49 -0500 159) 	private static final float TETHER_DENSITY = ENEMY_DENSITY;
2259a23f (benstevens        2016-03-12 22:19:49 -0500 160) 	private static final float TETHER_FRICTION = ENEMY_FRICTION;
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 161) 	private static final float TETHER_RESTITUTION = BASIC_RESTITUTION;
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 162) 
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 163) 	// Since these appear only once, we do not care about the magic numbers.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 164) 	// In an actual game, this information would go in a data file.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 165) 	// Wall vertices
5d18dc89 (oka2              2016-03-07 21:30:18 -0500 166) 	private static final float[][] LAND = {{}};
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 167) 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 168) 	private static final float[] WALL1 = { 0.0f, 18.0f, 16.0f, 18.0f, 16.0f, 17.0f,
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 169) 										   8.0f, 15.0f,  1.0f, 17.0f,  2.0f,  7.0f,
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 170) 										   3.0f,  5.0f,  3.0f,  1.0f, 16.0f,  1.0f,
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 171) 										  16.0f,  0.0f,  0.0f,  0.0f};
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 172) 	private static final float[] WALL2 = {32.0f, 18.0f, 32.0f,  0.0f, 16.0f,  0.0f,
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 173) 										  16.0f,  1.0f, 31.0f,  1.0f, 30.0f, 10.0f,
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 174) 										  31.0f, 16.0f, 16.0f, 17.0f, 16.0f, 18.0f};
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 175) 	private static final float[] WALL3 = { 4.0f, 10.5f,  8.0f, 10.5f,
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 176)             							   8.0f,  9.5f,  4.0f,  9.5f};
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 177) 	
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 178) 	private static final float[] WALLX = { 0.0f, 0.0f, 32.0f, 0.0f,
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 179) 										   16.0f, 32.0f, 0.0f, 0.0f, 16.0f};
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 180) 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 181) 	// The positions of the crate pyramid
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 182) //	private static final float[] BOXES = { 14.5f, 14.25f,
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 183) //            							   13.0f, 12.00f, 16.0f, 12.00f,
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 184) //            							   11.5f,  9.75f, 14.5f,  9.75f, 17.5f, 9.75f,
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 185) //            							   13.0f,  7.50f, 16.0f,  7.50f,
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 186) //            							   11.5f,  5.25f, 14.5f,  5.25f, 17.5f, 5.25f,
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 187) //            							   10.0f,  3.00f, 13.0f,  3.00f, 16.0f, 3.00f, 19.0f, 3.0f};
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 188) 	private static final float[] BOXES = {};
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 189) 	
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 190) 	private ArrayList<TetherModel> tethers = new ArrayList<TetherModel>();
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 191) 
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 192) 	// Other game objects
2259a23f (benstevens        2016-03-12 22:19:49 -0500 193) 	/** The initial koi position */
2259a23f (benstevens        2016-03-12 22:19:49 -0500 194) 	private static Vector2 KOI_POS = new Vector2(24, 4);
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 195) 	/** The goal door position */
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 196) 	private static Vector2 GOAL_POS = new Vector2( 6, 12);
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 197) 
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 198) 	// Physics objects for the game
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 199) 	/** Reference to the goalDoor (for collision detection) */
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 200) 	private BoxObstacle goalDoor;
2259a23f (benstevens        2016-03-12 22:19:49 -0500 201) 	/** Reference to the player avatar */
2259a23f (benstevens        2016-03-12 22:19:49 -0500 202) 	private PlayerFishModel koi;
03463b69 (tgb57             2016-03-07 21:18:27 -0500 203) 	
03463b69 (tgb57             2016-03-07 21:18:27 -0500 204) 	private EnemyFish eFish;
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 205) 
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 206) 	/**
2259a23f (benstevens        2016-03-12 22:19:49 -0500 207) 	 * Creates and initialize a new instance of Downstream
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 208) 	 *
2259a23f (benstevens        2016-03-12 22:19:49 -0500 209) 	 * The game has no  gravity and deafault settings
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 210) 	 */
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 211) 	public FishController() {
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 212) 		setDebug(false);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 213) 		setComplete(false);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 214) 		setFailure(false);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 215) 		world.setContactListener(this);
0e3c00aa (dashbrown         2016-03-07 21:20:57 -0500 216) 		tethered = false;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 217) 	}
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 218) 	
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 219) 	/**
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 220) 	 * Resets the status of the game so that we can play again.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 221) 	 *
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 222) 	 * This method disposes of the world and creates a new one.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 223) 	 */
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 224) 	public void reset() {
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 225) 		Vector2 gravity = new Vector2(world.getGravity() );
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 226) 		
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 227) 		for(Obstacle obj : objects) {
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 228) 			obj.deactivatePhysics(world);
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 229) 		}
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 230) 		objects.clear();
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 231) 		addQueue.clear();
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 232) 		world.dispose();
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 233) 		
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 234) 		world = new World(gravity,false);
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 235) 		world.setContactListener(this);
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 236) 		setComplete(false);
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 237) 		setFailure(false);
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 238) 		populateLevel();
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 239) 	}
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 240) 
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 241) 	/**
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 242) 	 * Lays out the game geography.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 243) 	 */
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 244) 	private void populateLevel() {
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 245) 		// Add level goal
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 246) 		float dwidth  = goalTile.getRegionWidth()/scale.x;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 247) 		float dheight = goalTile.getRegionHeight()/scale.y;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 248) 		
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 249) 		boolean sensorTethers = true;
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 250) 		
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 251) 		float rad = tetherTexture.getRegionWidth()/2;
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 252) 
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 253) 		
065cc3fc (dashbrown         2016-03-07 22:15:15 -0500 254) 		TetherModel tether = new TetherModel(12, 2, dwidth, dheight);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 255) 		tether.setBodyType(BodyDef.BodyType.StaticBody);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 256) 		tether.setName("tether"+ 1);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 257) 		tether.setDensity(TETHER_DENSITY);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 258) 		tether.setFriction(TETHER_FRICTION);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 259) 		tether.setRestitution(TETHER_RESTITUTION);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 260) 		tether.setSensor(sensorTethers);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 261) 		tether.setDrawScale(scale);
ca2f299a (dashbrown         2016-03-07 22:09:22 -0500 262) 		tether.setTexture(tetherTexture);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 263) 		addObject(tether);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 264) 		tethers.add(tether);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 265) 		
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 266) 		tether = new TetherModel(6, 12, dwidth, dheight);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 267) 		tether.setBodyType(BodyDef.BodyType.StaticBody);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 268) 		tether.setName("tether"+ 2);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 269) 		tether.setDensity(TETHER_DENSITY);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 270) 		tether.setFriction(TETHER_FRICTION);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 271) 		tether.setRestitution(TETHER_RESTITUTION);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 272) 		tether.setSensor(sensorTethers);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 273) 		tether.setDrawScale(scale);
ca2f299a (dashbrown         2016-03-07 22:09:22 -0500 274) 		tether.setTexture(tetherTexture);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 275) 		addObject(tether);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 276) 		tethers.add(tether);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 277) 		
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 278) 		tether = new TetherModel(28, 10, dwidth, dheight);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 279) 		tether.setBodyType(BodyDef.BodyType.StaticBody);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 280) 		tether.setName("tether"+ 3);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 281) 		tether.setDensity(TETHER_DENSITY);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 282) 		tether.setFriction(TETHER_FRICTION);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 283) 		tether.setRestitution(TETHER_RESTITUTION);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 284) 		tether.setSensor(sensorTethers);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 285) 		tether.setDrawScale(scale);
ca2f299a (dashbrown         2016-03-07 22:09:22 -0500 286) 		tether.setTexture(tetherTexture);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 287) 		addObject(tether);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 288) 		tethers.add(tether);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 289) 		
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 290) 		tether = new TetherModel(16, 14, dwidth, dheight);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 291) 		tether.setBodyType(BodyDef.BodyType.StaticBody);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 292) 		tether.setName("tether"+ 4);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 293) 		tether.setDensity(TETHER_DENSITY);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 294) 		tether.setFriction(TETHER_FRICTION);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 295) 		tether.setRestitution(TETHER_RESTITUTION);
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 296) 		tether.setSensor(sensorTethers);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 297) 		tether.setDrawScale(scale);
ca2f299a (dashbrown         2016-03-07 22:09:22 -0500 298) 		tether.setTexture(tetherTexture);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 299) 		addObject(tether);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 300) 		tethers.add(tether);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 301) 		
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 302) 
2259a23f (benstevens        2016-03-12 22:19:49 -0500 303) 		TextureRegion texture = enemyTexture;
03463b69 (tgb57             2016-03-07 21:18:27 -0500 304) 		dwidth  = texture.getRegionWidth()/scale.x;
03463b69 (tgb57             2016-03-07 21:18:27 -0500 305) 		dheight = texture.getRegionHeight()/scale.y;
03463b69 (tgb57             2016-03-07 21:18:27 -0500 306) 		eFish = new EnemyFish(20, 0, dwidth, dheight);
2259a23f (benstevens        2016-03-12 22:19:49 -0500 307) 		eFish.setDensity(ENEMY_DENSITY);
2259a23f (benstevens        2016-03-12 22:19:49 -0500 308) 		eFish.setFriction(ENEMY_FRICTION);
03463b69 (tgb57             2016-03-07 21:18:27 -0500 309) 		eFish.setRestitution(BASIC_RESTITUTION);
2259a23f (benstevens        2016-03-12 22:19:49 -0500 310) 		eFish.setName("enemy");
03463b69 (tgb57             2016-03-07 21:18:27 -0500 311) 		eFish.setDrawScale(scale);
03463b69 (tgb57             2016-03-07 21:18:27 -0500 312) 		eFish.setTexture(texture);
35567013 (benstevens        2016-03-12 11:58:05 -0500 313) 		eFish.setAngle((float) (Math.PI/2));
03463b69 (tgb57             2016-03-07 21:18:27 -0500 314) 		eFish.setBodyType(BodyDef.BodyType.StaticBody);
03463b69 (tgb57             2016-03-07 21:18:27 -0500 315) 		eFish.setGoal(0, 0);
03463b69 (tgb57             2016-03-07 21:18:27 -0500 316) 		addObject(eFish);
03463b69 (tgb57             2016-03-07 21:18:27 -0500 317) 		
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 318) 		
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 319) //		tether = new TetherModel(1, 6, dwidth, dheight);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 320) //		tether.setBodyType(BodyDef.BodyType.StaticBody);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 321) //		tether.setDensity(0.0f);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 322) //		tether.setFriction(0.0f);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 323) //		tether.setRestitution(0.0f);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 324) //		tether.setSensor(true);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 325) //		tether.setDrawScale(scale);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 326) //		tether.setTexture(goalTile);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 327) //		addObject(tether);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 328) //		tethers.add(tether);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 329) 		
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 330) 		// Create ground pieces
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 331) //		PolygonObstacle obj;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 332) //		obj = new PolygonObstacle(WALL1, 0, 0);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 333) //		obj.setBodyType(BodyDef.BodyType.StaticBody);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 334) //		obj.setDensity(BASIC_DENSITY);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 335) //		obj.setFriction(BASIC_FRICTION);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 336) //		obj.setRestitution(BASIC_RESTITUTION);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 337) //		obj.setDrawScale(scale);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 338) //		obj.setTexture(earthTile);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 339) //		obj.setName("wall1");
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 340) //		addObject(obj);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 341) //
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 342) //		obj = new PolygonObstacle(WALL2, 0, 0);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 343) //		obj.setBodyType(BodyDef.BodyType.StaticBody);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 344) //		obj.setDensity(BASIC_DENSITY);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 345) //		obj.setFriction(BASIC_FRICTION);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 346) //		obj.setRestitution(BASIC_RESTITUTION);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 347) //		obj.setDrawScale(scale);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 348) //		obj.setTexture(earthTile);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 349) //		obj.setName("wall2");
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 350) //		addObject(obj);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 351) 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 352) 
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 353) 		// Create the fish avatar
2259a23f (benstevens        2016-03-12 22:19:49 -0500 354) 		dwidth  = koiTexture.getRegionWidth()/scale.x;
2259a23f (benstevens        2016-03-12 22:19:49 -0500 355) 		dheight = koiTexture.getRegionHeight()/scale.y;
2259a23f (benstevens        2016-03-12 22:19:49 -0500 356) 		koi = new PlayerFishModel(KOI_POS.x, KOI_POS.y, dwidth, dheight);
2259a23f (benstevens        2016-03-12 22:19:49 -0500 357) 		koi.setDrawScale(scale);
2259a23f (benstevens        2016-03-12 22:19:49 -0500 358) 		koi.setName("koi");
2259a23f (benstevens        2016-03-12 22:19:49 -0500 359) 		koi.setTexture(koiTexture);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 360) 	  
2259a23f (benstevens        2016-03-12 22:19:49 -0500 361) 		addObject(koi);
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 362) 	}
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 363) 
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 364) 	/**
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 365) 	 * The core gameplay loop of this world.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 366) 	 *
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 367) 	 * This method contains the specific update code for this mini-game. It does
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 368) 	 * not handle collisions, as those are managed by the parent class WorldController.
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 369) 	 * This method is called after input is read, but before collisions are resolved.
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 370) 	 * The very last thing that it should do is apply forces to the appropriate objects.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 371) 	 *
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 372) 	 * @param delta Number of seconds since last animation frame
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 373) 	 */
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 374) 	public void update(float dt) {
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 375) 
2259a23f (benstevens        2016-03-12 22:19:49 -0500 376) 		float thrust = koi.getThrust();
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 377) 		InputController input = InputController.getInstance();
2259a23f (benstevens        2016-03-12 22:19:49 -0500 378) 		koi.setFX(thrust * input.getHorizontal());
2259a23f (benstevens        2016-03-12 22:19:49 -0500 379) 		koi.setFY(thrust * input.getVertical());
2259a23f (benstevens        2016-03-12 22:19:49 -0500 380) 		koi.applyForce();
2259a23f (benstevens        2016-03-12 22:19:49 -0500 381) 		koi.setLinearVelocity(koi.getLinearVelocity().setLength(8));
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 382) 		
00000000 (Not Committed Yet 2016-03-15 18:15:27 -0400 383) 		if (enableSlow && input.slow) koi.setLinearVelocity(koi.getLinearVelocity().setLength(4));
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 384) 		
0e3c00aa (dashbrown         2016-03-07 21:20:57 -0500 385) 		if (input.didLaunch()) tethered = !tethered;
0e3c00aa (dashbrown         2016-03-07 21:20:57 -0500 386) 		
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 387) 		TetherModel closestTether = getClosestTether();
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 388) 		
0e3c00aa (dashbrown         2016-03-07 21:20:57 -0500 389) //		if (tethered &&
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 390) 		if (input.space && 
00000000 (Not Committed Yet 2016-03-15 18:15:27 -0400 391) 			koi.getPosition().sub(koi.getInitialTangentPoint(closestTether.getPosition())).len2() < .01) {
00000000 (Not Committed Yet 2016-03-15 18:15:27 -0400 392) 			koi.applyTetherForce(closestTether);
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 393) //			System.out.println(fish.getInitialTangentPoint(closestTether.getPosition()));
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 394) 		}
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 395) 		
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 396) 		float angV = 3f;
2259a23f (benstevens        2016-03-12 22:19:49 -0500 397) 		float radius = closestTether.getPosition().dst(koi.getPosition());
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 398) 		float tetherSpeed = angV*radius;
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 399) 		
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 400) 		float MAX_SPEED = 7f;
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 401) 		float MIN_SPEED = 6f;
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 402) 		
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 403) 		int motionType = 0;
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 404) 		
edc44673 (dashbrown         2016-03-12 21:58:23 -0500 405) //		if (fish.getLinearVelocity().len2() != 0) {
edc44673 (dashbrown         2016-03-12 21:58:23 -0500 406) //			switch(motionType){
edc44673 (dashbrown         2016-03-12 21:58:23 -0500 407) //			case 0:
2259a23f (benstevens        2016-03-12 22:19:49 -0500 408) //				koi.setLinearVelocity(koi.getLinearVelocity().setLength(MAX_SPEED));
edc44673 (dashbrown         2016-03-12 21:58:23 -0500 409) //				break;
edc44673 (dashbrown         2016-03-12 21:58:23 -0500 410) //			case 1:
2259a23f (benstevens        2016-03-12 22:19:49 -0500 411) //				if (koi.getLinearVelocity().len() <= MAX_SPEED - 1 && input.accel){
2259a23f (benstevens        2016-03-12 22:19:49 -0500 412) //					koi.setLinearVelocity(koi.getLinearVelocity().setLength(koi.getLinearVelocity().len()+1));
edc44673 (dashbrown         2016-03-12 21:58:23 -0500 413) //				}
2259a23f (benstevens        2016-03-12 22:19:49 -0500 414) //				if (koi.getLinearVelocity().len() >= MIN_SPEED + 1 && input.deccel){
2259a23f (benstevens        2016-03-12 22:19:49 -0500 415) //					koi.setLinearVelocity(koi.getLinearVelocity().setLength(koi.getLinearVelocity().len()-1));
edc44673 (dashbrown         2016-03-12 21:58:23 -0500 416) //				}
edc44673 (dashbrown         2016-03-12 21:58:23 -0500 417) //				break;
edc44673 (dashbrown         2016-03-12 21:58:23 -0500 418) //			case 2:
2259a23f (benstevens        2016-03-12 22:19:49 -0500 419) //				koi.setLinearVelocity(koi.getLinearVelocity().setLength(tetherSpeed));
edc44673 (dashbrown         2016-03-12 21:58:23 -0500 420) //				break;
edc44673 (dashbrown         2016-03-12 21:58:23 -0500 421) //			}
edc44673 (dashbrown         2016-03-12 21:58:23 -0500 422) //		}
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 423) 		
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 424) 		
a1eb899a (benstevens        2016-03-10 11:06:51 -0500 425) 		
03463b69 (tgb57             2016-03-07 21:18:27 -0500 426) 		eFish.moveTowardsGoal();
03463b69 (tgb57             2016-03-07 21:18:27 -0500 427) 		eFish.patrol(20, 0, 20, 18);
35567013 (benstevens        2016-03-12 11:58:05 -0500 428) 		eFish.getGoal();
03463b69 (tgb57             2016-03-07 21:18:27 -0500 429) 		
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 430) 	    SoundController.getInstance().update();
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 431) 	}
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 432) 	
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 433) 	private TetherModel getClosestTether() {
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 434) 		TetherModel closestTether = tethers.get(0);
00000000 (Not Committed Yet 2016-03-15 18:15:27 -0400 435) 		float closestDistance = tethers.get(0).getPosition().sub(koi.getPosition()).len2();
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 436) 		for (TetherModel tether : tethers) {
00000000 (Not Committed Yet 2016-03-15 18:15:27 -0400 437) 			float newDistance = tether.getPosition().sub(koi.getPosition()).len2();
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 438) 			if (newDistance < closestDistance) {
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 439) 				closestDistance = newDistance;
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 440) 				closestTether = tether;
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 441) 			}
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 442) 		}
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 443) 		return closestTether;
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 444) 	}
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 445) 	
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 446) 	public void draw(float delta) {
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 447) 		super.draw(delta);
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 448) 		
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 449) 		if (enableLeadingLine) {
00000000 (Not Committed Yet 2016-03-15 18:15:27 -0400 450) 			Vector2 farOff = koi.getPosition().cpy();
00000000 (Not Committed Yet 2016-03-15 18:15:27 -0400 451) 			farOff.add(koi.getLinearVelocity().cpy().scl(1000));
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 452) //			System.out.println(fish.getPosition().cpy());
00000000 (Not Committed Yet 2016-03-15 18:15:27 -0400 453) 			canvas.drawLeadingLine(koi.getPosition().cpy(), farOff);
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 454) 		}
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 455) 		if (enableTetherRadius) {
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 456) 			Vector2 closestTether = getClosestTether().getPosition().cpy().scl(scale);
00000000 (Not Committed Yet 2016-03-15 18:15:27 -0400 457) 			Vector2 initialTangent = koi.getInitialTangentPoint(getClosestTether().getPosition()).scl(scale);
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 458) 			float radius = closestTether.dst(initialTangent);
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 459) //			System.out.println(fish.getInitialTangentPoint(closestTether));
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 460) //			System.out.println(fish.getPosition());
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 461) //			System.out.println(closestTether);
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 462) //			System.out.println(initialTangent);
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 463) //			System.out.println(radius);
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 464) //			System.out.println(scale);
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 465) 			
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 466) 			canvas.drawTetherCircle(closestTether, radius);
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 467) 		}
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 468) 		
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 469) 	}
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 470) 	
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 471) 	/// CONTACT LISTENER METHODS
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 472) 	/**
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 473) 	 * Callback method for the start of a collision
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 474) 	 *
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 475) 	 * This method is called when we first get a collision between two objects.  We use 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 476) 	 * this method to test if it is the "right" kind of collision.  In particular, we
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 477) 	 * use it to test if we made it to the win door.
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 478) 	 *
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 479) 	 * @param contact The two bodies that collided
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 480) 	 */
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 481) 	public void beginContact(Contact contact) {
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 482) 		Body body1 = contact.getFixtureA().getBody();
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 483) 		Body body2 = contact.getFixtureB().getBody();
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 484) 
2259a23f (benstevens        2016-03-12 22:19:49 -0500 485) 		if( (body1.getUserData() == koi   && body2.getUserData() == goalDoor) ||
2259a23f (benstevens        2016-03-12 22:19:49 -0500 486) 			(body1.getUserData() == goalDoor && body2.getUserData() == koi)) {
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 487) 			setComplete(true);
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 488) 		}
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 489) 	}
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 490) 	
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 491) 	/**
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 492) 	 * Callback method for the start of a collision
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 493) 	 *
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 494) 	 * This method is called when two objects cease to touch.  We do not use it.
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 495) 	 */ 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 496) 	public void endContact(Contact contact) {}
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 497) 	
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 498) 	private Vector2 cache = new Vector2();
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 499) 	
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 500) 	/** Unused ContactListener method */
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 501) 	public void postSolve(Contact contact, ContactImpulse impulse) {}
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 502) 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 503) 	/**
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 504) 	 * Handles any modifications necessary before collision resolution
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 505) 	 *
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 506) 	 * This method is called just before Box2D resolves a collision.  We use this method
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 507) 	 * to implement sound on contact, using the algorithms outlined similar to those in
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 508) 	 * Ian Parberry's "Introduction to Game Physics with Box2D".  
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 509) 	 * 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 510) 	 * However, we cannot use the proper algorithms, because LibGDX does not implement 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 511) 	 * b2GetPointStates from Box2D.  The danger with our approximation is that we may
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 512) 	 * get a collision over multiple frames (instead of detecting the first frame), and
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 513) 	 * so play a sound repeatedly.  Fortunately, the cooldown hack in SoundController
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 514) 	 * prevents this from happening.
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 515) 	 *
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 516) 	 * @param  contact  	The two bodies that collided
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 517) 	 * @param  oldManfold  	The collision manifold before contact
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 518) 	 */
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 519) 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 520) 	public void preSolve(Contact contact, Manifold oldManifold) {
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 521) 		float speed = 0;
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 522) 
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 523) 		// Use Ian Parberry's method to compute a speed threshold
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 524) 		Body body1 = contact.getFixtureA().getBody();
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 525) 		Body body2 = contact.getFixtureB().getBody();
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 526) 		WorldManifold worldManifold = contact.getWorldManifold();
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 527) 		Vector2 wp = worldManifold.getPoints()[0];
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 528) 		cache.set(body1.getLinearVelocityFromWorldPoint(wp));
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 529) 		cache.sub(body2.getLinearVelocityFromWorldPoint(wp));
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 530) 		speed = cache.dot(worldManifold.getNormal());
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 531) 		    
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 532) 		// Play a sound if above threshold
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 533) 		if (speed > SOUND_THRESHOLD) {
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 534) 			String s1 = ((Obstacle)body1.getUserData()).getName();
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 535) 			String s2 = ((Obstacle)body2.getUserData()).getName();
2259a23f (benstevens        2016-03-12 22:19:49 -0500 536) 			if (s1.equals("koi") || s1.startsWith("enemy") || s1.startsWith("tether")) {
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 537) 				SoundController.getInstance().play(s1, COLLISION_SOUND, false, 0.5f);
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 538) 			}
2259a23f (benstevens        2016-03-12 22:19:49 -0500 539) 			if (s2.equals("koi") || s2.startsWith("enemy") || s2.startsWith("tether")) {
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 540) 				SoundController.getInstance().play(s2, COLLISION_SOUND, false, 0.5f);
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 541) 			}
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 542) 		}
0c6a7bcf (oka2              2016-03-07 19:05:03 -0500 543) 	}
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 544) 	
b1c2ebfe (dashbrown         2016-03-15 18:12:39 -0400 545) 	
a46c70da (dashbrown         2016-03-07 20:55:04 -0500 546) }
